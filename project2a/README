NAME: Xilai Zhang
EMAIL: xilaizhang@g.ucla.edu
ID: 804796478

Makefile: support build,tests,graphs,dist,clean. To make each option usable by
itself, they have to be executed in a specific sequence. For example, make
tests is required to genereate the data before calling make graphs.
SortedList.c: the implementation of SortedList.h provided by the professor.
lab2a_add.c: use multiple threads to imcrement and decrement a pointer, in
order to observe different locking and yielding mechanisms.
lab2a_list.c: use multiple threads to insert, lookup, and delete a list, in
order to observe different locking and yielding mechanisms.
.csv files: the results of running binary files generated by .c files.
.png files: graphs required by the professor.
.gp files: professor provided files to generate gnuplot.

question 2.1.1

creating a thread can be time consuming and costly. When iterations is small,
the execution of increment and decrement of the counter might be done before
the next thread is created, and thus no two thread will enter the critical
section at the same time. When iterations is large, however, the critical
sections of different threads are more likely to overlap, and thus cause
failure.

question 2.1.2

yielding does not release enough CPU resource to counter the overhead and 
extra context switches introduced by yielding. In this case, the overhead
makes yielding much slower.
In this case, we cannot get valid per-operation timings. We cannot determine
at a given point, how many threads are running, and how many threads are
yielding, how many threads are context switching. Also, we are only measuring 
the wall time.

question 2.1.3

When we have large iterations, we spent more time doing real "work", and the
overhead caused by creating threads is less obvious. When we have small 
iterations, the overheads can take up a large percentage of the total cost.
Thus per operation cost drops with increasing iterations. 
when we look at graph such as lab2_add-3.png, the curve decreases and then
becomes fairly flat and stable. We find the turning point of the curve, and
that is the optimal iteration to run.

question 2.1.4

for low number of threads, not many threads are contending for the resources,
and thus the lock is mostly available, and thus there aren't many overhead
caused by locking mechanisms, and they perform similarly to unprotected
method.
When number of threads increase, threads start to contend for resource. 
The locking mechanism has to ensure that only one thread can enter the 
critical section at a time, and thus some threads are held waiting, and thus
slow down the program.   

question 2.2.1

They both have a linear increasing shape. As expected, more threads means more
contention and cost per operation becomes higher.
the rate of increase for list is higher than that of adds, because the 
implementation of list is more complex than that of adds, and the per operation
cost is thus more expensive.

question 2.2.2

Both mutex and spin lock have increasing shape. The slope of the spin lock 
is much higher than the slope of mutex. A possible explanation: mutex lets
the thread to sleep between the iterations. 
As we know, the add or insert
function cost the same amount of time. But as threads increase, the locking 
time increase: each CPU core trys to get exclusive write priviledge and value
is popped out to other cores. The time between two add(insert) calls increase.
And during this increasing time interval, the spin lock always run to check locking 
conditions, while the mutex put
idle threads to sleep, and thus spin lock has higher cost per operation.
 
sources used:
Linux man pages of unfamiliar functions
note: for non cs major student like me, to get gnuplot 5.0 instead of 4.6
i did: export path=/usr/local/cs/bin:$PATH
I also asked a question on Piazza, see question @282
Besides, I think the test script kept the .csv and .png files and do not wish
make clean to remove them. I asked a very detailed question on Piazza, see
question @293
Also, I used ./lab2_list instead of gnuplot lab2_list in my make graphs, 
because I am a EE student and doing the later will default gnuplot to 4.6.